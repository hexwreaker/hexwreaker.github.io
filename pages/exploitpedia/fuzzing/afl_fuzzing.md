---
layout: default
title: Hexwreaker Expoitpedia
---
#### [ExploitPedia](/pages/exploitpedia/exploitpedia)

# Fuzzing with AFL

1. see the [tutorial videos from "liveoverflow"](https://www.youtube.com/playlist?list=PLhixgUqwRTjy0gMuT4C3bmjeZjuNQyqdx)
1. [American fuzzing lop](https://github.com/google/AFL)
1. [Maintained project AFL++](https://github.com/AFLplusplus/AFLplusplus)

## Présentation

Le **fuzzing** est une technique pour [tester](https://fr.wikipedia.org/wiki/Test_(informatique) "Test (informatique)") des [logiciels](https://fr.wikipedia.org/wiki/Logiciel "Logiciel"). L'idée est d'injecter des [données aléatoires](https://fr.wikipedia.org/wiki/Variable_al%C3%A9atoire "Variable aléatoire") dans les entrées du programme cible et d'observer son comportement et les données en sortie. Si le programme échoue (par exemple en plantant ou en générant une erreur), alors il y a un bug. 

## American Fuzzy Lop

AFL (sa version maintenue est AFL++) est un fuzzer simple d'utilisation qui permet de réaliser des tests en **black-box** mais aussi en **white-box**. En effet, sa stratégie est d'instrumenter la cible afin d'analyser son comportement interne en fonction des entrées données.
Les tests en **white-box** sont plus efficace  mais nécessite de compiler la cible

## Utilisation

#### Instrumentation

Le programme cible est un binaire dont le code source n'est pas connue ce qui nous empêche d'instrumenter la cible afin d'utiliser AFL++ en mode **white-box**.
Cepandant, il est possible de décompiler la cible avec Ida Pro et de récupérer le code source généré afin de le recompiler avec **afl-clang-fast**.

	File -> Produce file -> Create C file

Le code source généré ressemble contient beaucoup de fonctions systèmes qui sont ajouté à la compilation et certaines autres références qu'il convient de retirer. Pour cela, nous avons écris un script python (*sanitize_ida_c_file.py*) qui permet de "nettoyer" le code généré afin de le rendre compilable, moyennant quelques correction de problèmes. 
Voici le code généré : 

![image](/src/images/Pasted image 20250119013033.png)


À présent, il est possible d'instrumenter la cible :

![image](/src/images/Pasted image 20250119013452.png)

L'instrumentation d'AFL consiste à ajouter des instructions qui permettent de suivre l'exécution de la cible.

![image](/src/images/Pasted image 20250119013837.png)
![image](/src/images/Pasted image 20250119014530.png)

#### Cas de tests

Avant  de lancer le fuzzer, il faut définir un cas initial pour lequel l'exécution réussi. C'est à partir de ce cas qu'AFL++ va muter les donnéees afin de trouver d'autres chemins.

Le cas initial peut être : 
![image](/src/images/Pasted image 20250119015105.png)

#### Fuzzing simple

AFL++ va exécuter la cible avec des données différentes à chaque fois, qui sont mutées à partir du cas initial.
Lorsqu'une exécution "crash", AFL journalise le cas dans le dossier de sortie.

Le lancement du fuzzing se fait avec la commande suivante : 

```
afl-fuzz -m none -i in/ -o out3/ -- ./mych6_afl
```

Un crash est survenu :

![image](/src/images/Pasted image 20250130114427.png)

Il n'existe pas de mode multithread mais Il est possible d'exécuter afl++ sur plusieurs coeurs en utilisant plusieurs processus.
Voici un script shell qui lance un processus "maître" suivi de 26 processus "esclaves" : 

```sh
#!/bin/sh
export AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES=1
export AFL_SKIP_CPUFREQ=1

# master
(afl-fuzz -m none -i in/ -o out2/ -M fuzz01 -- ./mych6_afl &)
# slaves
(afl-fuzz -m none -i in/ -o out2/ -S fuzz02 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz03 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz04 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz05 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz06 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz07 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz08 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz09 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz10 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz11 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz12 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz13 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz14 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz16 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz17 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz18 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz19 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz20 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz21 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz22 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz23 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz24 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz25 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz26 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz27 -- ./mych6_afl &) 1>/dev/null
(afl-fuzz -m none -i in/ -o out2/ -S fuzz28 -- ./mych6_afl &) 1>/dev/null

wait
```


##### Analyse des résultats

Le fuzzing ne garantit pas de découvrir tous les bugs dans un programme, et ce, quel que soit le temps que l'on alloue.
Une fois que l'on décide de stopper AFL++, on peut analyser les résultats obtenues dans le dossier ***"out2"***.

Il est possible de lire les statistiques du fuzzing : 

```
	$ cat ./out2/default/fuzzer_stats
```

On obtient, entre autres, les stats suivantes :

```
start_time        : 1738233791  
last_update       : 1738234141  
execs_done        : 23922  
execs_per_sec     : 68.48  
...
max_depth         : 2  
stability         : 100.00%  
bitmap_cvg        : 35.96%  
saved_crashes     : 1  
saved_hangs       : 11  
last_find         : 1738234064  
last_crash        : 1738233847  
last_hang         : 1738234061  
...
afl_banner        : ./mych6_afl  
afl_version       : ++4.21c  
command_line      : afl-fuzz -m none -i in/ -o out3/ -- ./mych6_afl
```

Les données utilisée lors du "crash" ont été sauvegardées dans ***"./out3/default/crashes/"***

![image](/src/images/Pasted image 20250130120248.png)

Il faut s'assurer que le programme originale crash aussi, en effet il se peut que l'instrumentation d'AFL++ a modifier le code.

Malheureusement la cible ne crash pas en conditions réelles. Snif...

#### Fuzzing avec harnais

À expliquer...





