<!DOCTYPE html>
<html lang="en">
<head class="page-header" role="banner">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexwreaker Expoitpedia</title>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    <canvas id="container"></canvas>
    <script src="/script.js"></script>

    <div id="main" class="main-content" role="main">
        <div id="nav-bar">
            <div id="nav-home" class="nav-item"><a href="/"><img src="/src/images/home.jpg"/></a></div>
        </div>
        <h4 id="exploitpedia"><a href="/pages/exploitpedia/exploitpedia">ExploitPedia</a></h4>

<h1 id="bypass-stack-smashing-protector-canary">Bypass Stack smashing protector, “Canary”</h1>

<h2 id="présentation">Présentation</h2>

<p>Le <strong>“Stack smashing protector”</strong> (SSP) dit <strong>“Canari”</strong>  est une mesure de détection des <strong>buffer overflows</strong>. Le principe repose sur une valeur <strong>aléatoire</strong> placée a la fin de la stack frame, et dont l’intégrité est vérifiée avant le retour de la fonction.</p>

<p>Voici le code compilé avec les canaries :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func:
    prologue

; Store canary on the stack
    mov rbx, QWORD[fs:0x28]
    mov QWORD[stack_canary], rbx
    ...
    body
    ...
; Check for corrupted canary, if yes fail
    mov rbx, QWORD[stack_canary]
    xor QWORD[fs:0x28], rbx
    je exit
    call __stack_chk_fail
exit:
    epilogue
    ret
</code></pre></div></div>

<p>Si un <strong>buffer overflow</strong> est survenu alors l’exécution se termine par l’appel de la fonction <strong>“__stack_chk_fail”</strong>.</p>

<p>Et l’erreur “Stack smashing detected” est affichée.</p>

<h2 id="lire-la-mémoire-information-leakage">Lire la mémoire (Information leakage)</h2>

<p>Lorsqu’un <strong>buffer overflow</strong> est détecté, le programme termine est une erreur est affiché par la fonction <strong>“__stack_chk_fail”</strong>. Cet fonction écrit le nom du programme qui vient de terminer, à l’aide du pointeur des arguments en début de pile.</p>

<p>Ce mécanisme peut être exploité pour lire la mémoire du programme en réecrivant le pointeur du nom du programme. Ainsi le buffer overflow est, certes, détecté mais l’information fuit et l’attaquant peut accéder à la mémoire complète.</p>


    </div>
</body>
</html>
